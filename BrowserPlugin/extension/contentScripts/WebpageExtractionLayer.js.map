{"version":3,"sources":["webpack://extension/./node_modules/page-metadata-parser/parser.js","webpack://extension/./node_modules/page-metadata-parser/url-utils.js","webpack://extension/ignored|/home/empeor/work/COLLEGE/final_year_project/application/git/UCD/keepliving_inthe_past_man_fyp/BrowserPlugin/node_modules/page-metadata-parser|url","webpack://extension/webpack/bootstrap","webpack://extension/webpack/runtime/compat get default export","webpack://extension/webpack/runtime/define property getters","webpack://extension/webpack/runtime/global","webpack://extension/webpack/runtime/hasOwnProperty shorthand","webpack://extension/webpack/runtime/make namespace object","webpack://extension/./src/contentScripts/WebPageExtractionLayer.js"],"names":[],"mappings":";;;;;;;AAAA,OAAO,0BAA0B,GAAG,mBAAO,CAAC,GAAa;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,iCAAiC;AAC3D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClMA,IAAI,qBAAM;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,mBAAO,CAAC,GAAK;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;AC3BA,e;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;WACA,CAAC,I;;;;;WCPD,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;ACNyD;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B,CAAC;;AAED;AACA,qBAAqB,uEAAiC;;AAEtD;;AAEA;;AAEA,+CAA+C;;AAE/C,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"contentScripts/WebpageExtractionLayer.js","sourcesContent":["const {makeUrlAbsolute, parseUrl} = require('./url-utils');\n\nfunction getProvider(host) {\n  return host\n    .replace(/www[a-zA-Z0-9]*\\./, '')\n    .replace('.co.', '.')\n    .split('.')\n    .slice(0, -1)\n    .join(' ');\n}\n\nfunction buildRuleSet(ruleSet) {\n  return (doc, context) => {\n    let maxScore = 0;\n    let maxValue;\n\n    for (let currRule = 0; currRule < ruleSet.rules.length; currRule++) {\n      const [query, handler] = ruleSet.rules[currRule];\n\n      const elements = Array.from(doc.querySelectorAll(query));\n\n      if(elements.length) {\n        for (const element of elements) {\n          let score = ruleSet.rules.length - currRule;\n\n          if (ruleSet.scorers) {\n            for (const scorer of ruleSet.scorers) {\n              const newScore = scorer(element, score);\n\n              if (newScore) {\n                score = newScore;\n              }\n            }\n          }\n\n          if (score > maxScore) {\n            maxScore = score;\n            maxValue = handler(element);\n          }\n        }\n      }\n    }\n\n    if (!maxValue && ruleSet.defaultValue) {\n      maxValue = ruleSet.defaultValue(context);\n    }\n\n    if (maxValue) {\n      if (ruleSet.processors) {\n        for (const processor of ruleSet.processors) {\n          maxValue = processor(maxValue, context);\n        }\n      }\n\n      if (maxValue.trim) {\n        maxValue = maxValue.trim();\n      }\n\n      return maxValue;\n    }\n  };\n}\n\nconst metadataRuleSets = {\n  description: {\n    rules: [\n      ['meta[property=\"og:description\"]', element => element.getAttribute('content')],\n      ['meta[name=\"description\" i]', element => element.getAttribute('content')],\n    ],\n  },\n\n  icon: {\n    rules: [\n      ['link[rel=\"apple-touch-icon\"]', element => element.getAttribute('href')],\n      ['link[rel=\"apple-touch-icon-precomposed\"]', element => element.getAttribute('href')],\n      ['link[rel=\"icon\" i]', element => element.getAttribute('href')],\n      ['link[rel=\"fluid-icon\"]', element => element.getAttribute('href')],\n      ['link[rel=\"shortcut icon\"]', element => element.getAttribute('href')],\n      ['link[rel=\"Shortcut Icon\"]', element => element.getAttribute('href')],\n      ['link[rel=\"mask-icon\"]', element => element.getAttribute('href')],\n    ],\n    scorers: [\n      // Handles the case where multiple icons are listed with specific sizes ie\n      // <link rel=\"icon\" href=\"small.png\" sizes=\"16x16\">\n      // <link rel=\"icon\" href=\"large.png\" sizes=\"32x32\">\n      (element, score) => {\n        const sizes = element.getAttribute('sizes');\n\n        if (sizes) {\n          const sizeMatches = sizes.match(/\\d+/g);\n          if (sizeMatches) {\n            return sizeMatches[0];\n          }\n        }\n      }\n    ],\n    defaultValue: (context) => 'favicon.ico',\n    processors: [\n      (icon_url, context) => makeUrlAbsolute(context.url, icon_url)\n    ]\n  },\n\n  image: {\n    rules: [\n      ['meta[property=\"og:image:secure_url\"]', element => element.getAttribute('content')],\n      ['meta[property=\"og:image:url\"]', element => element.getAttribute('content')],\n      ['meta[property=\"og:image\"]', element => element.getAttribute('content')],\n      ['meta[name=\"twitter:image\"]', element => element.getAttribute('content')],\n      ['meta[property=\"twitter:image\"]', element => element.getAttribute('content')],\n      ['meta[name=\"thumbnail\"]', element => element.getAttribute('content')],\n    ],\n    processors: [\n      (image_url, context) => makeUrlAbsolute(context.url, image_url)\n    ],\n  },\n\n  keywords: {\n    rules: [\n      ['meta[name=\"keywords\" i]', element => element.getAttribute('content')],\n    ],\n    processors: [\n      (keywords, context) => keywords.split(',').map((keyword) => keyword.trim())\n    ]\n  },\n\n  title: {\n    rules: [\n      ['meta[property=\"og:title\"]', element => element.getAttribute('content')],\n      ['meta[name=\"twitter:title\"]', element => element.getAttribute('content')],\n      ['meta[property=\"twitter:title\"]', element => element.getAttribute('content')],\n      ['meta[name=\"hdl\"]', element => element.getAttribute('content')],\n      ['title', element => element.text],\n    ],\n  },\n\n  language: {\n    rules: [\n      ['html[lang]', element => element.getAttribute('lang')],\n      ['meta[name=\"language\" i]', element => element.getAttribute('content')],\n    ],\n    processors: [\n      (language, context) => language.split('-')[0]\n    ]\n  },\n\n  type: {\n    rules: [\n      ['meta[property=\"og:type\"]', element => element.getAttribute('content')],\n    ],\n  },\n\n  url: {\n    rules: [\n      ['a.amp-canurl', element => element.getAttribute('href')],\n      ['link[rel=\"canonical\"]', element => element.getAttribute('href')],\n      ['meta[property=\"og:url\"]', element => element.getAttribute('content')],\n    ],\n    defaultValue: (context) => context.url,\n    processors: [\n      (url, context) => makeUrlAbsolute(context.url, url)\n    ]\n  },\n\n  provider: {\n    rules: [\n      ['meta[property=\"og:site_name\"]', element => element.getAttribute('content')]\n    ],\n    defaultValue: (context) => getProvider(parseUrl(context.url))\n  },\n};\n\nfunction getMetadata(doc, url, customRuleSets) {\n  const metadata = {};\n  const context = {\n    url,\n  };\n\n  const ruleSets = customRuleSets || metadataRuleSets;\n\n  Object.keys(ruleSets).map(ruleSetKey => {\n    const ruleSet = ruleSets[ruleSetKey];\n    const builtRuleSet = buildRuleSet(ruleSet);\n\n    metadata[ruleSetKey] = builtRuleSet(doc, context);\n  });\n\n  return metadata;\n}\n\nmodule.exports = {\n  buildRuleSet,\n  getMetadata,\n  getProvider,\n  metadataRuleSets\n};\n","if (global.URL !== undefined) {\n  // We're in Firefox\n  module.exports = {\n    makeUrlAbsolute(base, relative) {\n      return new URL(relative, base).href;\n    },\n    parseUrl(url) {\n      return new URL(url).host;\n    }\n  };\n} else {\n  // We're in Node.js\n  const urlparse = require('url');\n  module.exports = {\n    makeUrlAbsolute(base, relative) {\n      const relativeParsed = urlparse.parse(relative);\n\n      if (relativeParsed.host === null) {\n        return urlparse.resolve(base, relative);\n      }\n\n      return relative;\n    },\n    parseUrl(url) {\n      return urlparse.parse(url).hostname;\n    }\n  };\n}\n\n","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import webpageMetadataParser from \"page-metadata-parser\";\n\nconsole.log(\"WebpageExtrractionLayer has been imported\")\n\n/**\n * This will listen for messages from the background scripts\n */\nbrowser.runtime.onMessage.addListener(request => {\n    if(request.messageType == \"askForTitle\"){\n        console.log(\"current page being asked for title\")\n\n        return Promise.resolve(document.title);\n    }\n    else if(request.messageType == \"askForScrapings\"){\n\n        console.log(\"The page is being asked to scrape\")\n        \n        let webpageMetadata = getWebpageMetadata();\n\n        webpageMetadata[\"scrapedContent\"] = ScrapeWebPage();\n        \n        return Promise.resolve(webpageMetadata);\n    }\n    return Promise.resolve({});\n});\n\nfunction getWebpageMetadata(){\n    const metadata = webpageMetadataParser.getMetadata(document, window.location)\n\n    const webpageTitle = encodeURIComponent(metadata.title);\n    \n    const webpageImageUrl = ((metadata.image !== undefined)? encodeURI(metadata.image):((metadata.icon !== undefined)? encodeURI(metadata.icon) : null));\n\n    const webpageUrl = encodeURI(metadata.url); //TODO: I DONT KNOW IF CANONICAL URL IS BETTER. i THINK IT IS. SHOULD BE REPLACED\n\n    return {title:webpageTitle, url: webpageUrl, imgUrl: webpageImageUrl}\n}\n\n/**\n * @description\n * scrapes the web page of \n * @returns \n * html body text\n */\nfunction ScrapeWebPage(){\n    return document.body.innerText.trim().replace(/[^a-zA-Z ]/g, \" \").replace(/\\s\\s+/g, ' ');\n}"],"sourceRoot":""}